<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/static/base.css"/>
        <link rel="stylesheet" type="text/css" href="/static/prism.css"/>
        <title>How to Grammar Good with Nearley - Comfortably Numbered</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <meta charset="utf-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
        <script src="/static/prism.js"></script>
        <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script>
            MathJax.Hub.Config({
                tex2jax: {inlineMath: [['($','$)']]}
            });
        </script>
    </head>
    <body>

        <div id="header">
    <link rel="stylesheet" href="/octicons/octicons.css">
    <h1>
        <a href="/"><span class="left-word">Comfortably</span><span class="right-word">Numbered</span></a>
    </h1>
    <div id="rightbox">
        <a href="http://github.com/Hardmath123">
            <span class="octicon octicon-mark-github"></span></a>
        &nbsp;&middot;&nbsp;
        <a href="http://keybase.io/hardmath123">
            <span class="octicon octicon-lock"></span></a>
        &nbsp;&middot;&nbsp;
        <a href="/feed.xml">
            <span class="octicon octicon-rss"></span></a>
    </div>
    <div class="clearer"></div>
    <!-- You're reading the source to my blog? What do you think?

    Do you have dinner plans? -->
</div>


        <div id="postcontent" class="language-clike centered">
            <h2>How to Grammar Good with Nearley</h2>
            <h4>Saturday, May 2, 2015
            </h4>
            <br/>
            <p>A lot of people have pointed out to me that writing grammars for
<a href="http://hardmath123.github.io/nearley/">nearley</a> is <em>hard</em>. The thing is,
writing grammars is, in general, very hard. It doesn’t help that certain
grammar-related problems are provably undecidable.</p>
<p>As with all of programming, grammar-writing is guided by instinct and pattern
recognition (on the part of the human, in this case!). This guide is meant to
walk through some common idioms, ideas, anti-patterns and pitfalls, and
hopefully make you a confident grammarian. Treat it more as a styleguide than a
tutorial.</p>
<p>It might be worth reading <a href="/earley.html">Better Earley than Never</a> first, to
understand the algorithm and some basic concepts. From here on out, I’m
assuming you know what <em>regular expression</em>, <em>Backus Naur Form</em>, <em>context free
grammar</em>, <em>terminal</em>, <em>nonterminal</em>, and <em>ambiguous grammar</em> mean. You should
know nearley syntax well enough to understand what something like</p>
<pre><code>int -&gt; [0-9]        {% id %}
    | int [0-9]     {% function(d) {return d[0] + d[1]} %}
</code></pre><p>means (though I like to pride myself on the readability of nearley grammar…).</p>
<h3 id="structure">Structure</h3>
<p>Your grammar should be structured from the top down. The first few rules in a
file should describe a general outline, and tiny details (terminals for
whitespace, literals etc.) should be at the bottom. For example, if you’re
writing a parser for Scheme, you would start with</p>
<pre><code>Sourcefile -&gt; (S-expression | Comment):*
</code></pre><p>and then fill out what <code>s-expression</code> and <code>comment</code> mean. Most of the time,
rules defined higher in the file reference rules defined lower down, and rules
defined near the bottom rarely ever reference rules near the top.</p>
<h3 id="nonterminal-names">Nonterminal names</h3>
<p>Give your nonterminals useful names—mostly nouns that describe the string it
will match. By convention, we use <code>_</code> for optional whitespace and <code>__</code> for
mandatory whitespace: it makes it easy to write rules like</p>
<pre><code>&quot;(&quot; _ expression _ &quot;)&quot;
</code></pre><p>You can explicitly mark a nonterminal as optional or repetitive by postfixing
its name with <code>?</code> and <code>+</code> (respectively)—as in <code>statementlist+</code> or <code>comment?</code>.
Note that this has no semantic value: use nearley’s EBNF modifiers (<code>:*</code>, <code>:+</code>,
<code>:?</code>) for that.</p>
<h3 id="don-t-roll-your-own-unroller">Don’t roll your own unroller</h3>
<p>If you want to match one or more of a nonterminal, use an EBNF modifier. It’s
semantically legible, contextually appropriate and (most importantly) easy.
It’s very easy to mess up and create an exponentially ambiguous monstrosity
such as</p>
<pre><code>lotsofletters -&gt; &quot;a&quot; | lotsofletters lotsofletters
</code></pre><h3 id="postprocess-or-dispose">Postprocess or dispose</h3>
<p>nearley saves a nested array structure by default, but most of the time that’s
not what you want. For things like whitespace, you want to throw away all that
useless information for memory efficiency, so use a postprocessor that just
returns <code>null</code>. For syntactic sugar and stuff, construct object literals so
that the code that processes your AST is relatively independent of your
grammar. Constructing object literals also lets you discard junk (parens,
etc.).</p>
<h3 id="remember-charclasses-aren-t-regexes">Remember, charclasses aren’t regexes</h3>
<p>The <code>[a-z]</code> syntax only allows you to use regex-style character classes, not
actual regular expressions. Nearley fundamentally does not support regexes as
terminals. Use EBNF modifiers instead—they do what you want.</p>
<h3 id="debug-with-nearley-test">Debug with nearley-test</h3>
<p>Use the <code>nearley-test</code> script (installs alongside <code>nearleyc</code>) to debug your
grammars. It lets you inspect the parse tables, and see all the parsings, or
the point of failure. This is invaluable when you have a subtle ambiguity
issue.</p>
<h3 id="don-t-shy-away-from-left-recursion">Don’t shy away from left recursion</h3>
<p>You were a good little student and you payed attention to your professors when
they told you never to write grammars like:</p>
<pre><code>a -&gt; a &quot;something&quot;
</code></pre><p>because a naïve recursive-descent parser would bork in an infinite loop.
Nearley, of course, is much better, so you don’t have to worry about that. If
you’re paranoid about efficiency, you should actually prefer left recursion
over right recursion (<code>a -&gt; &quot;something&quot; a</code>) because it’s very slightly faster.
In any case, that’s how you deal with left or right associativity for binary
operators.</p>
<h3 id="do-shy-away-from-left-recursion">Do shy away from left recursion</h3>
<p>…if you’re using it where the EBNF <code>:*</code> or <code>:+</code> makes more sense!</p>
<h3 id="operator-precedence-is-not-black-magic">Operator precedence is not black magic</h3>
<p>Here’s how you do it: you start with your lowest-precedence operator and work
your way up to your highest precedence ones. Each operator gets its own
nonterminal:</p>
<pre><code>math -&gt; sum
sum -&gt; sum (&quot;+&quot;|&quot;-&quot;) product | product
product -&gt; product (&quot;*&quot;|&quot;/&quot;) exp | exp
exp -&gt; number &quot;^&quot; exp | number # this is right associative!
</code></pre><p>It should be pretty clear how this works, and how to extend it to different
types of operators. The main thing is to be careful with your associativity
direction. Be careful not to write <code>op -&gt; op &quot;$&quot; op</code>, because that’s ambiguous.</p>
<p>Introducing non-conflicting unary negation (<code>&quot;5 * -5&quot;</code>) is left as a trivial
exercise for the enterprising reader.</p>
<h3 id="comment-your-grammars">Comment your grammars</h3>
<p>It’s very easy to come back to a grammar a week later and have no idea what
it’s doing. Leave comments that explain precisely what each nonterminal
matches, since a clear description will help you debug things in the future.</p>
<h3 id="use-whitespace-prettily">Use whitespace prettily</h3>
<p>Align your <code>-&gt;</code>s and your <code>|</code>s and your <code>{% ... %}</code>s. Future retinas will thank
you.</p>
<h3 id="parsing-an-established-language-cheat-">Parsing an established language? Cheat!</h3>
<p>Almost all standards publish syntax guides with an accompanying diagram in
(E)BNF. It’s worth it to Google around for this. With just a bit of common
sense, you should be able to transliterate it to a <code>.ne</code> file.</p>
<hr>
<p>Again, grammar-writing is largely about instinct and experience. The more you
write, the more you’ll understand how it goes, and the faster you’ll be able to
prototype and design.</p>

            <div id="disqus_thread"></div>
            <script type="text/javascript">
                var disqus_shortname = 'comfortablynumbered';
                var disqus_identifier = 'nearley-tips.md';
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            </script>
        <div id="footer">
    Comfortably Numbered &middot; Hardmath123 (2013) &middot; <a href="feed.xml">RSS</a>
    &nbsp;&middot;&nbsp;
    <a href="/appreciation.html">
        <span class="octicon octicon-beer"></span></a>
    <div style="height: 10px;">&nbsp;</div>
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/deed.en_US">
        <img
            alt="Creative Commons License"
            src="http://i.creativecommons.org/l/by-nc/3.0/80x15.png"/>
    </a>

    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-46120535-1', 'hardmath123.github.io');
        ga('require', 'displayfeatures');
        ga('send', 'pageview');
    </script>
</div>

    </body>
</html>
